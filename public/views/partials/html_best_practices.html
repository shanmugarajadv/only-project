<div class="padding">
    <div class="full col-sm-12">

        <div class="col-sm-12">
            <div class="page-header text-muted col1-color">
                <a><h2>HTML - Best Practices</h2></a>
            </div>
        </div>

        <!-- content -->
        <div class="col-sm-12">
            <div class="page-header text-muted">
                Use web storage in place of cookies
            </div>
        </div>

        <!--/top story-->
        <div class="row col-sm-12">
            <div class="col-sm-10">
                <p>While cookies have been used to track unique user data for years, they have serious disadvantages. The largest flaw is that all of your cookie data is added to every HTTP request header. This can end up having a measurable impact on response time, especially during XHRs. So a best practice is to reduce cookie size. In HTML5 we can do better than that: use sessionStorage and localStorage in place of cookies.</p>

<p>These two web storage objects can be used to persist user data on the clientside for the length of the session or indefinitely. Their data is not transferred to the server via every HTTP request, either. They have an API that will make you happy to be rid of cookies. Here are both APIs, using cookies as a fallback.</p>

<code><pre>// if localStorage is present, use that
if (('localStorage' in window) && window.localStorage !== null) {

  // easy object property API
  localStorage.wishlist = '["Unicorn","Narwhal","Deathbear"]';

} else {

  // without sessionStorage we'll have to use a far-future cookie
  //   with document.cookie's awkward API :(
  var date = new Date();
  date.setTime(date.getTime()+(365*24*60*60*1000));
  var expires = date.toGMTString();
  var cookiestr = 'wishlist=["Unicorn","Narwhal","Deathbear"];'+
                  ' expires='+expires+'; path=/';
  document.cookie = cookiestr;
}</pre></code>
            </div>
        </div>

        <div class="col-sm-12">
            <div class="page-header text-muted divider">
                Use CSS Transitions instead of JavaScript animation
            </div>
        </div>
	<div class="row col-sm-12">
            <div class="col-sm-10">
                <p>CSS Transitions give you an attractive visual transition between two states. Most style properties can be transitioned, like manipulating the text-shadow, position, background or color. You can use transitions into pseudo-selector states like :hover or from HTML5 forms, :invalid and :valid (example with form validation states). But they're much more powerful and can be triggered when you add any class to an element.</p>
		<code><pre> div.box {
  left: 40px;
  -webkit-transition: all 0.3s ease-out;
     -moz-transition: all 0.3s ease-out;
       -o-transition: all 0.3s ease-out;
          transition: all 0.3s ease-out;
}
div.box.totheleft { left: 0px; }
div.box.totheright { left: 80px; }</pre></code>
		<p>By adding the toggling the classes of totheleft and totheright you can move the box around. Compare this amount of code with that of a JavaScript animation library. Clearly, the number of bytes sent to the browser is much less when using CSS-based animation. Additionally, with GPU level acceleration, these visual transitions will be as smooth as possible.</p>
            </div>
        </div>
        <div <div class="row col-sm-12">
            <div class="col-sm-10">
                <p>Web SQL Database and IndexedDB introduce databases to the clientside. Instead of the common pattern of posting data to the server via XMLHttpRequest or form submission, you can leverage these clientside databases. Decreasing HTTP requests is a primary target of all performance engineers, so using these as a datastore can save many trips via XHR or form posts back to the server. localStorage and sessionStorage could be used in some cases, like capturing form submission progress, and have seen to be noticeably faster than the client-side database APIs.</p>

<p>For example, if you have a data grid component or an inbox with hundreds of messages, storing the data locally in a database will save you HTTP roundtrips when the user wishes to search, filter, or sort. A list of friends or a text input autocomplete could be filtered on each keystroke, making for a much more responsive user experience. Certainly view the Web SQL Database tutorial for a comprehensive guide at putting this to work.</p>
            </div>
        </div>

        <div class="col-sm-12">
            <div class="page-header text-muted divider">
                Use cache manifest for live sites, not just offline apps
            </div>
        </div>
        <div class="row col-sm-12">
            <div class="col-sm-10">
                <p>Two years back, Wordpress used Google Gears to add a feature called Wordpress Turbo. It essentially cached many of the resources used in the admin panel locally, speeding up file access to them. We can replicate that behavior with HTML5's applicationCache and the cache.manifest.</p>

<p>The app cache has a slight advantage over setting Expires headers; because you make a declarative file indicating the static resources that can be cacheable, browsers can optimize that heavily, perhaps even precaching them ahead of your use.</p>

<p>Consider your site's basic structure as a template. You have data that may change but the HTML around it typically remains pretty consistent. With the app cache you could treat your HTML as a series of pure templates, cache the markup via the cache.manifest, and then deliver JSON over the wire to update the content. This model is very similar to what an iPhone or Android native news app does.</p>
            </div>
        </div>
	<div class="col-sm-12">
            <div class="page-header text-muted divider">
                HTML5 Form attributes and input types
            </div>
        </div>
        <div class="row col-sm-12">
            <div class="col-sm-10">
                <p>HTML5 introduces a new set of input types, upgrading our set of text, password, and file to include search, tel, url, email, datetime, date, month, week, time, datetime-local, number, range and color. Browser support for these vary, with Opera implementing most at the moment. With feature detection you can determine if the browser has native support (and will offer a UI like a datepicker or color picker) and if not, you can continue to use the JS widgets to accomplish these common tasks.</p>

<p>In addition to the types, a few useful features have been added to our normal input fields. The input placeholder offers default text that clears when you click into them and autofocus focuses the caret on page load so you can interact immediately with that field. Input validation is another thing making its way in with HTML5. Adding the required attribute means the browser won't let the form submit until that field is filled in. Also the pattern attribute lets you specify a custom regular expression for the input to be tested against; with invalid values blocking form submission. This declarative syntax is a big upgrade not only in source readability but also a significant reduction of JavaScript necessary. Again, you can use feature detection to serve a fallback solution if there isn't native support for these present.</p>

<p>Using the native widgets here means you don't need to send the heavy javascript and css required to pull off these widgets, speeding up page load and likely improving widget responsiveness. To try out some of these input enhancements check out the HTML5 Slide deck.</p>
            </div>
        </div>
	<div class="col-sm-12">
            <div class="page-header text-muted divider">
                Use CSS3 effects instead of requesting heavy image sprites
            </div>
        </div>
        <div class="row col-sm-12">
            <div class="col-sm-10">
                <p>CSS3 delivers many new styling possibilities that supplant our use of images to represent the visual design accurately. Replacing a 2k image with 100 bytes of CSS is a huge win, not to mention you've removed yet another HTTP request. A few of the properties to familiarize yourself with are:</p>

<ul>
<li>Linear and radial gradients</li>
<li>Border-radius for rounded corners</li>
<li>Box-shadow for drop shadows and glow</li>
<li>RGBA for alpha opacity</li>
<li>Transforms for rotation</li>
<li>CSS masks</li>
</ul>

<p>For example you, can create very polished buttons via gradients and replicate many other effects sans-images. Browser support for most of these is very solid, and you can use a library like Modernizr to catch browsers that don't support the features in order to use images in a fallback case.</p>
            </div>
        </div>
        <div class="col-sm-12" id="featured">
            <div class="page-header text-muted">
                <h5>Related</h5>
            </div>
        </div>

        <div class="row">
            <div class="col-sm-4 text-center col2-color">
                <a href="#/htmlDemo"><h4>Live Demo</h4>
                    <span class="glyphicon glyphicon-play"></span></a>
            </div>
            <div class="col-sm-4 text-center col3-color">
                <a href="#/htmlTroubleshoot"><h4>Troubleshooting</h4>
                    <span class="glyphicon glyphicon-eye-open"></span></a>
            </div>
        </div>

        <div class="col-sm-12">
            <div class="page-header text-muted">

            </div>
        </div>
    </div>
    <!-- /col-9 -->
</div><!-- /padding -->
